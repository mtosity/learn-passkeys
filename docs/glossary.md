# WebAuthn Glossary

A comprehensive reference of terms used in WebAuthn and passkey authentication.

## Core Concepts

### Authenticator
A device or software component that:
- Creates and stores cryptographic credentials
- Performs user verification (biometric, PIN, etc.)
- Signs authentication challenges

**Types:**
- **Platform Authenticator**: Built into the device (Touch ID, Windows Hello, Face ID)
- **Roaming Authenticator**: External device (YubiKey, USB security key)
- **Cross-platform Authenticator**: Can be used across multiple devices

**Examples:**
- Your MacBook's Touch ID sensor
- YubiKey USB security key
- Android phone's fingerprint scanner

### WebAuthn (Web Authentication)
A W3C standard API that enables passwordless authentication using public key cryptography. It's built into modern browsers and allows websites to register and authenticate users without passwords.

### FIDO2
An authentication standard that includes:
- WebAuthn (the browser API)
- CTAP2 (protocol for external authenticators)

Think of FIDO2 as the umbrella standard, with WebAuthn being the web component.

### Passkey
A user-friendly term for a WebAuthn credential. When you "create a passkey," you're creating a WebAuthn credential using your device's authenticator.

**Note:** "Passkey" is marketing-friendly language. Technically, you're creating a public-private key pair.

## Cryptographic Concepts

### Public Key
The cryptographic key that:
- Is stored on your server
- Can verify signatures
- Is safe to share publicly
- Cannot decrypt messages encrypted with it (in most schemes)
- Cannot be used to derive the private key

**In WebAuthn:** Server stores the public key to verify authentication signatures.

### Private Key
The cryptographic key that:
- Stays on the authenticator device FOREVER
- Never transmitted over network
- Never stored on your server
- Used to create signatures
- Must be kept secret

**In WebAuthn:** The private key signs authentication challenges to prove ownership.

### Key Pair
A matched set of public and private keys:
```
Private Key (secret) + Public Key (public) = Key Pair
```

**What you can do:**
- Sign data with private key → Anyone can verify with public key
- Encrypt with public key → Only private key can decrypt

### Digital Signature
Cryptographic proof that:
- Data was signed by holder of private key
- Data hasn't been tampered with
- Provides authentication and integrity

**In WebAuthn:**
```
Challenge + Private Key → Signature
Server verifies: Signature + Public Key + Challenge = Valid/Invalid
```

### Challenge
A random value (typically 32 bytes) generated by the server for each authentication ceremony:

**Properties:**
- Cryptographically random
- Used exactly once
- Expires quickly (5 minutes typical)
- Different for every registration/authentication

**Purpose:** Prevents replay attacks - old signatures can't be reused.

### Attestation
Cryptographic proof about the authenticator itself:
- What type of authenticator was used?
- Who manufactured it?
- Is it hardware-based or software?

**Attestation Formats:**
- `none`: No attestation (simplest, most common)
- `packed`: Standard FIDO attestation
- `tpm`: Trusted Platform Module
- `android-key`: Android Key Attestation
- `android-safetynet`: Android SafetyNet
- `apple`: Apple's attestation format

**Use case:** Require hardware security keys for high-security accounts.

## WebAuthn-Specific Terms

### Relying Party (RP)
Your website/application that relies on the authenticator for authentication.

**Components:**
- **RP ID**: Your domain (e.g., "example.com" or "localhost")
- **RP Name**: Human-readable name ("My Cool App")

**Example:**
```javascript
rp: {
  name: "Learn Passkeys",
  id: "localhost"  // In production: "example.com"
}
```

### RP ID (Relying Party ID)
The domain that credentials are bound to:

**Rules:**
- Must be a valid domain
- Must match (or be parent of) current origin
- Credentials only work on this domain
- Provides phishing protection

**Examples:**
```
Valid RP ID for https://app.example.com:
- "app.example.com" ✅
- "example.com" ✅ (parent domain)
- "evil.com" ❌

For development:
- "localhost" ✅
```

### Origin
The full URL scheme + domain + port:

**Examples:**
```
https://example.com:443
http://localhost:8080
https://app.example.com
```

**In WebAuthn:** Origin must match the RP ID for security.

### Credential
A WebAuthn credential consists of:
- **Credential ID**: Unique identifier
- **Public Key**: For signature verification
- **Counter**: Signature counter
- **User Handle**: User identifier
- **Transports**: How it was created (usb, nfc, ble, internal)

**Stored in your database** for each user.

### Credential ID
A unique identifier for a credential:
- Generated by the authenticator
- Used to look up the right credential
- Sent in authentication requests
- No sensitive information (safe to store)

**Format:** Typically base64url-encoded bytes

### User Handle
An identifier for the user:
- Stored in the credential
- Returned during authentication
- Helps identify which user is authenticating
- Should be opaque (don't use email/username)

**Best practice:** Use a UUID or random identifier

### Resident Credential / Discoverable Credential
A credential stored on the authenticator that includes user information:

**Benefits:**
- User doesn't need to type username
- Authenticator can suggest credentials
- Better UX for passwordless flow

**Drawbacks:**
- Limited storage on authenticator
- Not all authenticators support it

**Alternative:** Non-resident credentials require server to tell authenticator which credential to use.

### Ceremony
A WebAuthn operation:
- **Registration Ceremony**: Creating a new credential
- **Authentication Ceremony**: Using a credential to log in

**Why "ceremony"?** It's a multi-step protocol between browser, authenticator, and server.

## Authentication Flow Terms

### Registration
The process of creating a new credential:

**Steps:**
1. Server generates challenge
2. Browser calls `navigator.credentials.create()`
3. User verifies (biometric/PIN)
4. Authenticator creates key pair
5. Public key returned to server
6. Server stores credential

### Authentication
The process of logging in with a credential:

**Steps:**
1. Server generates challenge
2. Browser calls `navigator.credentials.get()`
3. User verifies (biometric/PIN)
4. Authenticator signs challenge
5. Signature returned to server
6. Server verifies signature

### Assertion
The response from an authentication ceremony:
- Contains authenticator data
- Contains signature
- Contains client data
- Used to verify the user

**Think of it as:** The authenticator "asserting" that the user is who they claim to be.

### Client Data JSON
JSON object created by the browser containing:
```json
{
  "type": "webauthn.create" or "webauthn.get",
  "challenge": "base64url_challenge",
  "origin": "https://example.com",
  "crossOrigin": false
}
```

**Server must verify:**
- Type is correct
- Challenge matches
- Origin matches RP ID

### Authenticator Data
Binary data from the authenticator containing:
- RP ID hash (32 bytes)
- Flags byte (user present, user verified, etc.)
- Signature counter (4 bytes)
- Attested credential data (for registration)

**Format:** Defined by WebAuthn spec, usually parsed by libraries.

### Counter / Signature Counter
A monotonically increasing value:
- Increments with each authentication
- Stored on authenticator
- Stored in database
- Detects cloned authenticators

**Security check:**
```
If new_counter <= stored_counter:
  → Possible cloned credential
  → Revoke credential and alert user
```

## User Verification

### User Presence (UP)
Proof that user is physically present:
- Touch the security key
- Press a button
- Simple interaction

**Flag in authenticator data:** `UP` bit set

### User Verification (UV)
Proof that user identity was verified:
- Biometric (fingerprint, face)
- PIN entry
- Password on security key

**Flag in authenticator data:** `UV` bit set

**Requirement Levels:**
- `required`: Must have UV or fail
- `preferred`: Ask for UV if available
- `discouraged`: Don't ask for UV

### User Verification Requirement
Setting in options:
```javascript
{
  authenticatorSelection: {
    userVerification: "required"  // or "preferred" or "discouraged"
  }
}
```

**Use cases:**
- `required`: High-security operations (banking, admin)
- `preferred`: Normal login (use biometric if available)
- `discouraged`: Low-security (presence is enough)

## Security Concepts

### Origin Binding
Credentials are cryptographically bound to the origin:
- Credential only works on the domain it was created for
- Prevents phishing
- Built into the protocol

**Example:**
```
Credential created on: bank.com
Works on: bank.com ✅
Works on: fake-bank.com ❌
```

### Replay Attack
Attack where an attacker reuses old authentication data:

**How WebAuthn prevents it:**
1. Each challenge is unique and random
2. Challenges expire (5 minutes)
3. Challenges are single-use
4. Server tracks and invalidates used challenges

### Phishing Resistance
Property where authentication cannot be phished:

**How WebAuthn achieves this:**
- Origin binding (credential only works on correct domain)
- No shared secrets (nothing to steal)
- User can't be tricked into revealing credential

**Contrast with passwords:**
- Passwords can be entered on fake sites
- Users can be tricked into revealing them
- Works on any site (not origin-bound)

### Man-in-the-Middle (MITM) Resistance
WebAuthn credentials cannot be intercepted and reused:

**Protections:**
- HTTPS required (encrypted channel)
- Challenge prevents replay
- Origin binding prevents forwarding
- No shared secrets to steal

## API Concepts

### `navigator.credentials.create()`
Browser API for registration:
```javascript
const credential = await navigator.credentials.create({
  publicKey: {
    challenge: Uint8Array,
    rp: { name, id },
    user: { id, name, displayName },
    pubKeyCredParams: [...],
    timeout: 60000,
    attestation: "none"
  }
});
```

Returns a `PublicKeyCredential` with attestation.

### `navigator.credentials.get()`
Browser API for authentication:
```javascript
const assertion = await navigator.credentials.get({
  publicKey: {
    challenge: Uint8Array,
    rpId: "example.com",
    allowCredentials: [{
      type: "public-key",
      id: credentialId
    }],
    timeout: 60000,
    userVerification: "preferred"
  }
});
```

Returns a `PublicKeyCredential` with assertion.

### PublicKeyCredentialCreationOptions
Options for credential creation (registration):

**Required fields:**
- `challenge`: Random bytes from server
- `rp`: Relying party info
- `user`: User info
- `pubKeyCredParams`: Acceptable algorithms

**Optional fields:**
- `timeout`: Time to wait for user (milliseconds)
- `attestation`: Attestation preference
- `authenticatorSelection`: Authenticator requirements
- `excludeCredentials`: Don't allow re-registration

### PublicKeyCredentialRequestOptions
Options for getting credentials (authentication):

**Required fields:**
- `challenge`: Random bytes from server

**Optional fields:**
- `rpId`: Relying party identifier
- `allowCredentials`: Which credentials are acceptable
- `timeout`: Time to wait for user
- `userVerification`: UV requirement

### allowCredentials
Array of credentials that can be used for authentication:

```javascript
allowCredentials: [
  {
    type: "public-key",
    id: base64url_credential_id,
    transports: ["internal", "usb"]
  }
]
```

**Two modes:**
1. **Specific credentials**: Provide credential IDs (username-first flow)
2. **Empty array**: Let authenticator suggest (discoverable credentials)

### pubKeyCredParams
Acceptable public key algorithms:

```javascript
pubKeyCredParams: [
  { alg: -7, type: "public-key" },   // ES256 (ECDSA)
  { alg: -257, type: "public-key" }  // RS256 (RSA)
]
```

**Common algorithms:**
- `-7`: ES256 (ECDSA with P-256 and SHA-256)
- `-257`: RS256 (RSA with SHA-256)
- `-8`: EdDSA

### Transports
How the authenticator communicates:

- `internal`: Platform authenticator (Touch ID, Windows Hello)
- `usb`: USB security key
- `nfc`: NFC security key
- `ble`: Bluetooth security key

**Usage:** Hint to browser where to look for credentials.

## Go Library Terms

### `webauthn.WebAuthn`
Main interface from go-webauthn/webauthn library:

```go
webAuthn, err := webauthn.New(&webauthn.Config{
  RPDisplayName: "Learn Passkeys",
  RPID:          "localhost",
  RPOrigin:      "http://localhost:8080",
})
```

### `webauthn.User` interface
Interface your user struct must implement:

```go
type User interface {
  WebAuthnID() []byte
  WebAuthnName() string
  WebAuthnDisplayName() string
  WebAuthnCredentials() []Credential
}
```

### `webauthn.Credential`
Struct representing a stored credential:

```go
type Credential struct {
  ID              []byte
  PublicKey       []byte
  AttestationType string
  Transport       []AuthenticatorTransport
  Flags           CredentialFlags
  Authenticator   Authenticator
}
```

### `webauthn.SessionData`
Data to store during registration/authentication:

```go
type SessionData struct {
  Challenge        []byte
  UserID           []byte
  AllowedCredentials [][]byte
  // ... other fields
}
```

**Important:** Store this in session or database during the ceremony.

## Database Terms

### Schema
The structure of your database tables:

**For this project:**
- `users`: User accounts
- `credentials`: Stored credentials
- `challenges`: Temporary challenge storage (optional)
- `sessions`: User sessions

### Migration
The process of creating/updating database schema:

**Common tools:**
- SQL scripts (init.sql)
- golang-migrate
- Goose
- Manual with psql

### Foreign Key
A reference from one table to another:

```sql
CREATE TABLE credentials (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),  -- Foreign key
  ...
);
```

Ensures credentials always reference a valid user.

## Frontend Terms

### `@simplewebauthn/browser`
NPM package that simplifies WebAuthn on the frontend:

**Main functions:**
- `startRegistration(options)`: Handles credential creation
- `startAuthentication(options)`: Handles authentication
- Handles encoding/decoding automatically

### Base64URL
URL-safe base64 encoding:
- Uses `-` instead of `+`
- Uses `_` instead of `/`
- No padding `=`

**Why:** URLs and JSON don't like standard base64 characters.

**Libraries handle this for you!**

### CORS (Cross-Origin Resource Sharing)
Browser security that restricts cross-origin requests:

**For this project:**
```go
// Allow frontend (port 5173) to call backend (port 8080)
w.Header().Set("Access-Control-Allow-Origin", "http://localhost:5173")
w.Header().Set("Access-Control-Allow-Credentials", "true")
```

## Common Acronyms

- **FIDO**: Fast IDentity Online
- **CTAP**: Client to Authenticator Protocol
- **RP**: Relying Party
- **UP**: User Presence
- **UV**: User Verification
- **COSE**: CBOR Object Signing and Encryption
- **CBOR**: Concise Binary Object Representation
- **ES256**: ECDSA with P-256 curve and SHA-256
- **RS256**: RSA with SHA-256
- **TPM**: Trusted Platform Module

## Quick Reference

### Registration Flow Keywords
- Challenge generation
- PublicKeyCredentialCreationOptions
- navigator.credentials.create()
- Attestation object
- Public key extraction
- Credential storage

### Authentication Flow Keywords
- Challenge generation
- PublicKeyCredentialRequestOptions
- navigator.credentials.get()
- Assertion
- Signature verification
- Session creation

### Security Keywords
- Origin binding
- Phishing resistance
- Replay attack prevention
- No shared secrets
- Counter validation

## Learning Tips

1. **Start with high-level concepts** (this glossary)
2. **Understand the flows** (registration and authentication diagrams)
3. **Learn by implementing** (build the project step-by-step)
4. **Use libraries** (don't implement crypto yourself!)
5. **Test thoroughly** (multiple devices, error cases)

## When You See These Terms...

**In Documentation:**
- "Ceremony" → Registration or authentication process
- "Assertion" → Authentication response
- "Attestation" → Registration response (proof about authenticator)
- "RP" → Your server/website
- "UV" → Biometric/PIN verification
- "UP" → User touched/interacted

**In Code:**
- `challenge` → Random bytes from server
- `credentialId` → Unique identifier for credential
- `publicKey` → Stored key for verification
- `signature` → Signed challenge from authenticator
- `origin` → Full URL of your website
- `rpId` → Your domain

**In Errors:**
- "Origin mismatch" → RP ID doesn't match domain
- "Challenge mismatch" → Wrong challenge or expired
- "Verification failed" → Signature invalid
- "No credentials" → User hasn't registered
- "User cancelled" → User dismissed prompt

---

**Pro tip:** Bookmark this glossary and refer back as you encounter new terms while building your project!
